use.miden::account
use.miden::contracts::wallets::basic->wallet
use.miden::note
use.miden::tx
use.std::math::u64
use.std::sys

# CONSTANTS
# =================================================================================================

const.MAX_U32=0x0000000100000000
const.BASE=1000 # 1e3
const.DIV=1000 # 1e3

# Memory Addresses for AMM calculations
const.POOL_X = 0x0040
const.POOL_Y = 0x0041
const.DX_IN = 0x0042
const.DY_OUT = 0x0043

# Run time u64 memory addresses
const.DX_MUL_Y_BASE = 100
const.DX_PLUS_Y = 104

# ERRORS
const.OVERFLOW="value larger than 32 bits"

const.BALANCES_SLOT=0

# AMM CALCULATION
# =================================================================================================

#! Calculates the amount of asset Y to return given input of asset X
#! Formula: dy = (dx * y) / (dx + y)
#!
#! Assumes input values are base 1e3
#! Returns dy as fixed point 1e3
#!
#! Inputs: [x, y, dx]
#! Outputs: [dy]
export.get_amount_y_out
    mem_store.POOL_X
    mem_store.POOL_Y
    mem_store.DX_IN
    # => []

    mem_load.DX_IN
    u32split
    # => [dx_high, dx_low]

    mem_load.POOL_Y
    u32split
    # => [y_high, y_low, dx_high, dx_low]

    exec.u64::wrapping_mul
    # => [dxy_high, dyx_low]

    push.0.0
    # => [0, 0, dxyb_high, dyxb_low]

    mem_storew.DX_MUL_Y_BASE dropw
    # => []

    mem_load.DX_IN
    u32split
    # => [dx_high, dx_low]

    mem_load.POOL_Y
    u32split
    # => [dx_high, dx_low, y_high, y_low]

    exec.u64::wrapping_add
    # => [sum_dx_y_high, sum_dx_y_low]

    padw mem_loadw.DX_MUL_Y_BASE drop drop
    # => [dxyb_high, dyxb_low, sum_dx_y_high, sum_dx_y_low]

    movup.3 movup.3
    # => [sum_dx_y_high, sum_dx_y_low, dxyb_high, dyxb_low]

    exec.u64::div
    # => [dy_base_high, dy_base_low]

    eq.0 assert.err=OVERFLOW

    exec.sys::truncate_stack
end

# procedure to deploy network account onchain
export.deploy_contract
    push.0.0.0.0
    # => [KEY]

    push.BALANCES_SLOT
    # => [slot, KEY]

    exec.account::get_map_item
    # => [VALUE]

    padw
    # => [EMPTY_WORD, VALUE]

    assert_eqw
    # => []

    push.1.1.1.1
    # => [VALUE]

    padw
    # => [KEY, VALUE]

    push.BALANCES_SLOT
    # => [slot]

    exec.account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE]

    dropw dropw
    # => []
end

# => [faucet_x_prefix, faucet_x_suffix, faucet_y_prefix, faucet_y_suffix, OUPUT_NOTE]
export.swap

    ### ____ AMM COMPUTATION ____

    # get balance faucet_id_in
    call.account::get_balance
    # => [token_x_balance, faucet_y_prefix, faucet_y_suffix, OUPUT_NOTE]

    mem_store.POOL_X
    # => [faucet_y_prefix, faucet_y_suffix, OUPUT_NOTE]

    # get balance faucet_id_out
    call.account::get_balance
    # => [token_y_balance]

    mem_store.POOL_Y
    # => [OUPUT_NOTE]

    push.0 exec.note::get_assets
    # => [OUPUT_NOTE]

    mem_loadw.0
    # => [DX_ASSET, OUPUT_NOTE]

    drop drop drop
    # => [dx, OUPUT_NOTE]

    # mem_store.DX_IN
    # => [OUPUT_NOTE]

    mem_load.POOL_Y
    mem_load.POOL_X
    # => [x, y, dx, OUTPUT_NOTE]

    exec.get_amount_y_out
    # => [dy]

    # => get asset amount in amount from input note

    # => call get_amount_y_out

    # __ ASSET HANDLING __

    # => receive note in asset

    # => create OUPUT_NOTE

    # => add asset to note using get_amount_y_out

end

# Deposit assets into the contract
# Expects the asset to be on the stack: [ASSET]
# => []
export.deposit
    # => [ASSET]

    dupw
    # => [ASSET, ASSET]

    # Store the asset in the account's vault
    call.wallet::receive_asset
    # => [ASSET]

    exec.note::get_sender
    # => [sender, ASSET]

    push.0 movdn.2 push.0 movdn.2
    # => [SENDER, ASSET]

    push.BALANCES_SLOT
    # => [slot, SENDER, ASSET]

    exec.account::set_map_item
    # => [OLD_MAP_ROOT, OLD_MAP_VALUE]

    dropw dropw

    exec.sys::truncate_stack
    # => []
end

# => [tag, aux, note_type, execution_hint, RECIPIENT]
export.withdraw
    # => [tag, aux, note_type, execution_hint, RECIPIENT]

    call.tx::create_note
    # => [note_idx]

    exec.note::get_sender
    # => [sender, note_idx]

    push.0 movdn.2 push.0 movdn.2
    # => [SENDER]

    push.BALANCES_SLOT
    # => [slot, SENDER, note_idx]

    exec.account::get_map_item
    # => [ASSET, note_idx]

    call.wallet::move_asset_to_note
    # => [ASSET, note_idx]

    dropw drop

    exec.sys::truncate_stack
    # => []
end
